(function () {
    "use strict";

    const {blockRulesLib, stateLib} = window.WEB_API_MANAGER;
    const Vue = window.Vue;

    /**
     * A function for reducing an array of BlockRule objects into
     * two arrays, one containing BlockRule objects that should not
     * be imported (b/c they match and existing rule and the "should overwrite"
     * option was not checked), and the other an array of BlockRule objects
     * that should be imported.
     *
     * Note that this function assumes that the user has *not* checked the
     * "should overwrite" option, since if they have, there is no reason to
     * perform any filtering (every rule will be imported).
     *
     * @param {Preferences} prefs
     *   The preferences object, describing which rules the user has configured
     *   so far.
     * @param {Array.<?Array.BlockRule, ?Array.BlockRule>} collection
     *   The existing two arrays of block rules.  The incoming `rule`
     *   will be placed into one of these two bins.
     * @param {BlockRule} rule
     *   A block rule that will either be sorted into the "should ignore"
     *   bin (collection[0]) or the "should import" bin (collection[1]).
     *
     * @return {Array.<?Array.BlockRule, ?Array.BlockRule>}
     *   The `collection` array, with the `rule` object added to one of the
     *   two child arrays.
     */
    const reduceNewRules = (prefs, collection, rule) => {
        const newPattern = rule.getPattern();
        const currentRule = prefs.getRuleForPattern(newPattern);
        const isExistingRule = currentRule !== undefined;

        const [rulesToSkip, rulesToImport] = collection;
        if (isExistingRule === true) {
            rulesToSkip.push(rule);
        } else {
            rulesToImport.push(rule);
        }

        return collection;
    };

    /**
     * Checks to make sure the given string is a valid set of data to import
     * as block rules.
     *
     * @param {string} jsonString
     *   A JSON string, describing zero or more DomainBlock rules, in the
     *   format generated by `BlockRule.toJSON`.
     *
     * @return {Object}
     *   An object describing whether the given string was a valid data export,
     *   and whether it can be imported.  If so, the "success" key of the
     *   object will be true, and the "data" key will be an array of BlockRule
     *   objects.  If the string is invalid, the "success" key will be false,
     *   and the "data" key will be a string describing the error.
     */
    const parseImportString = jsonString => {
        let parsedData;

        try {
            parsedData = JSON.parse(jsonString);
        } catch (e) {
            return {success: false, data: e};
        }

        try {
            const rules = parsedData.map(aRuleRaw => {
                return blockRulesLib.fromData(aRuleRaw);
            });
            return {success: true, data: rules};
        } catch (e) {
            return {success: false, data: e};
        }
    };

    const generateExportString = (patternsToExport, preferences) => {
        const ruleData = patternsToExport.map(pattern => {
            return preferences.getRuleForPattern(pattern).toData();
        });
        return JSON.stringify(ruleData);
    };

    Vue.component("import-export", {
        props: ["dataPatterns"],
        render: window.WEB_API_MANAGER.vueComponents["import-export"].render,
        staticRenderFns: window.WEB_API_MANAGER.vueComponents["import-export"].staticRenderFns,
        data: function () {
            return {
                exportedData: "",
                patternsToExport: [],
                importError: false,
                importLog: "",
                importTextAreaValue: "",
                dataToImport: undefined,
                shouldOverwrite: false,
            };
        },
        methods: {
            onImportClicked: function (event) {
                const state = this.$root.$data;

                if (!this.isValidToImport()) {
                    this.importError = true;
                    this.dataToImport = undefined;
                    this.importLog = "No data to import.";
                    return;
                }

                const shouldOverwrite = !!this.shouldOverwrite;
                const preferences = state.preferences;
                const newRules = this.dataToImport;
                this.importLog = "";

                // In order to limit the amount of cross-boundary (content
                // script to background script) serializaton needed, we
                // want to only sync with the backed on the the last rule
                // imported.  In order to do this, we need to
                //   1) Identify which rules will cause changes (ie
                //      filter out rules that match existing rules and will
                //      be skipped b/c the "should overwrite" checkbox is
                //      not checked).
                //   2) Update the local (config page) copy of the preferences
                //      for every imported rule
                //   3) On the last imported rule, instruct the local version
                //      of the preferences object to syncronize with the
                //      background / true one.
                let rulesToSkip;
                let rulesToImport;

                if (shouldOverwrite === true) {
                    rulesToSkip = [];
                    rulesToImport = newRules;
                } else {
                    const reducer = reduceNewRules.bind(undefined, preferences);
                    [rulesToSkip, rulesToImport] = newRules.reduce(reducer, [[], []]);
                }

                const logMessagesReSkippedRules = rulesToSkip.map(rule => {
                    return ` ! ${rule.getPattern()}: Skipped. Set to not override.`;
                });

                const numRulesToImport = rulesToImport.length;
                const indexOfFinalRule = numRulesToImport - 1;
                const logMessagesReImportedRules = rulesToImport.map((rule, index) => {
                    const isFinalRule = indexOfFinalRule === index;
                    stateLib.upcertRule(state, rule, isFinalRule);
                    const numStandards = rule.getStandardIds().length;
                    return ` * ${rule.getPattern()}: Blocking ${numStandards} standards.`;
                });

                this.importError = false;
                this.importLog = logMessagesReSkippedRules.concat(logMessagesReImportedRules).join("\n");

                event.stopPropagation();
                event.preventDefault();
            },
            isValidToImport: function () {
                return (this.importError === false) && (this.dataToImport !== undefined);
            },
        },
        watch: {
            selectedStandardIds: function () {
                const state = this.$root.$data;
                this.exportedData = generateExportString(
                    this.patternsToExport,
                    state.preferences
                );
            },
            patternsToExport: function (selectedPatterns) {
                const state = this.$root.$data;
                this.exportedData = generateExportString(
                    selectedPatterns,
                    state.preferences
                );
            },
            importTextAreaValue: function () {
                const value = this.importTextAreaValue;

                if (value.trim() === "") {
                    this.dataToImport = undefined;
                    this.importError = false;
                    this.importLog = "";
                    return;
                }

                // The provided JSON should be an array of values generated
                // by `BlockRule.toJSON`.
                const {success, data} = parseImportString(value);
                if (success !== true) {
                    this.dataToImport = undefined;
                    this.importError = true;
                    this.importLog = data;
                    return;
                }

                this.dataToImport = data;
                this.importError = false;
                this.importLog = "";
            },
        },
    });
}());
