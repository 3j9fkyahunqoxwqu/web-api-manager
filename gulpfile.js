const fs = require("fs");
const path = require("path");
const gulp = require("gulp");
const compiler = require("vue-template-compiler");

const uft8Enc = {encoding: "utf8"};
const wrapInFunc = function (string) {
    return `function () {${string}}`;
};

gulp.task("clean", function () {

    const derivedFilePathSegments = [
        ["add-on", "lib", "standards.js"],
        ["add-on", "lib", "third_party", "sjcl.js"],
        ["add-on", "lib", "third_party", "uri.all.min.js"],
        ["add-on", "config", "js", "third_party", "vue.runtime.min.js"],
    ];

    const derivedFilePaths = derivedFilePathSegments.map(segs => path.join(...segs));

    derivedFilePaths.forEach(function (filepath) {

        if (!fs.existsSync(filepath)) {
            return;
        }

        fs.unlinkSync(filepath);
    });

    const vueCompiledTemplatesDirPath = path.join("add-on", "config", "js", "vue_compiled_templates");

    if (fs.existsSync(vueCompiledTemplatesDirPath)) {
        fs.readdirSync(vueCompiledTemplatesDirPath).forEach(function (filepath) {
            const pathToCompiledTemplate = path.join(vueCompiledTemplatesDirPath, filepath);
            fs.unlinkSync(pathToCompiledTemplate);
        });
    }
});

gulp.task("default", function () {

    const builtScriptComment = "/** This file is automatically generated. **/\n";
    const standardsDefDir = path.join("sources", "standards");

    // Build all the standards listings into a single features.js file.
    const combinedStandards = fs.readdirSync(standardsDefDir)
        .reduce(function (prev, next) {

            if (next.indexOf(".json") === -1) {
                return prev;
            }

            const fileContents = fs.readFileSync(path.join(standardsDefDir, next), uft8Enc);
            let standardContents;
            try {
                standardContents = JSON.parse(fileContents);
            } catch (e) {
                console.log("Invalid JSON in " + next);
                throw e;
            }

            prev[standardContents.info.id] = standardContents;
            return prev;
        }, {});

    let renderedStandardsModule = builtScriptComment;
    renderedStandardsModule += "window.WEB_API_MANAGER.standards = ";
    renderedStandardsModule += JSON.stringify(combinedStandards) + ";";

    fs.writeFileSync(path.join("add-on", "lib", "standards.js"), renderedStandardsModule);

    const thirdPartyConfigDirPath = path.join("add-on", "config", "js", "third_party");
    if (!fs.existsSync(thirdPartyConfigDirPath)) {
        fs.mkdirSync(thirdPartyConfigDirPath);
    }

    const sjclSourcePath = path.join("node_modules", "sjcl", "sjcl.js");
    const sjclDestPath = path.join("add-on", "lib", "third_party", "sjcl.js");
    fs.copyFileSync(sjclSourcePath, sjclDestPath);

    const vueSourcePath = path.join("node_modules", "vue", "dist", "vue.runtime.min.js");
    const vueDestPath = path.join("add-on", "config", "js", "third_party", "vue.runtime.min.js");
    fs.copyFileSync(vueSourcePath, vueDestPath);

    const uriSourcePath = path.join("node_modules", "uri-js", "dist", "es5", "uri.all.min.js");
    const uriDestPath = path.join("add-on", "lib", "third_party", "uri.all.min.js");

    fs.copyFileSync(uriSourcePath, uriDestPath);

    // Now compile the vue templates into render functions, so that we
    // can run in the CSP safe, VUE runtime.
    const vueTemplatesSourcePath = path.join("sources", "vue");
    const vueTemplatesDestPath = path.join("add-on", "config", "js", "vue_compiled_templates");
    if (!fs.existsSync(vueTemplatesDestPath)) {
        fs.mkdirSync(vueTemplatesDestPath);
    }

    fs.readdirSync(vueTemplatesSourcePath).forEach(function (filepath) {
        const absolutePath = path.join(__dirname, vueTemplatesSourcePath, filepath);
        const fileSource = fs.readFileSync(absolutePath, uft8Enc);

        const compilationResult = compiler.compile(fileSource);

        if (compilationResult.errors.length > 0) {
            console.error("Errors when compiling Vue templates: ");
            compilationResult.errors.forEach(console.error);
            process.exit(1);
        }

        if (compilationResult.tips.length > 0) {
            console.log("Suggestions from the Vue compiler: ");
            compilationResult.errors.forEach(console.log);
            process.exit(1);
        }

        const staticFuncsAsStrings = compilationResult.staticRenderFns.map(wrapInFunc);

        const compiledRenderFunction = `
/* This file is derived from sources/vue/${filepath}. */
if (window.WEB_API_MANAGER.vueComponents === undefined) {
    window.WEB_API_MANAGER.vueComponents = {};
}

window.WEB_API_MANAGER.vueComponents["${filepath.replace(".vue.html", "")}"] = {
    render: ${wrapInFunc(compilationResult.render)},
    staticRenderFns: [${staticFuncsAsStrings.join(",")}]
};`;

        const destPath = path.join(vueTemplatesDestPath, filepath + ".js");
        fs.writeFileSync(destPath, compiledRenderFunction);
    });
});
