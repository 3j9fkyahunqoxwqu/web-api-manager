/**
 * Module for parsing WebIDL text into the keypaths where the defined methods
 * and properties are located in the DOM.
 */
const fs = require("fs");
const path = require("path");
const webidl2 = require("webidl2");

const desiredMemberTypes = ["attribute", "operation"];

/**
 * Adds a member (as described by the AST format of webidl2) to an objects
 * "methods" or "properties" collection as appropriate.
 *
 * This method is meant to be used when reducing a collection of members
 * down to a single collection (through a combination of bind and reduce).
 *
 * @param {string} interfaceName
 *   The name of the interface the member is attached to.
 * @param {object.<string, array.string>} collection
 *   An object with a "methods" key, and a "properties" key, both pointing
 *   to arrays of strings.
 * @param {object} member
 *   An object representing a member of an interface definition, in the format
 *   generated by the webidl2 parse method.
 *
 * @return {object.<string, array.string>}
 *   The passed collection object, but with a string added to the "methods"
 *   or "properties" array, or no changes made if the member was not of
 *   a relevant type.
 */
const addAstMemeberToCollection = (interfaceName, collection, member) => {
    if (desiredMemberTypes.indexOf(member.type) === -1) {
        return collection;
    }

    const memberBin = member.type === "attribute"
        ? "properties"
        : "methods";

    const memberPathParts = [interfaceName];
    if (member.static === false) {
        memberPathParts.push("prototype");
    }
    memberPathParts.push(member.name);

    const memberPath = memberPathParts.join(".");

    if (collection[memberBin].indexOf(memberPath) === -1) {
        collection[memberBin].push(memberPath);
    }

    return collection;
};

/**
 * Adds a webidl2 generated AST for an interface to a collection
 * (mapping) of interface names, to the properties and methods are defined in
 * each interface.
 *
 * This function is intended to be used when reducing a collection of interface
 * ASTs (generated by the webidl2.parse method) to a single collection.
 *
 * @param {object.<string, object.<string, array.string>>}
 *
 * @param {object} interfaceAst
 *   A object depicting the AST for an interface, in the format
 *   returned from the webidl2.parse method.
 *
 * @return {object.<string, object.<string, array.string>>}
 *   An object that maps interface names to the properties and methods
 *   defined on those interfaces, in the WebIDL text.
 */
const addInterfaceAstToCollection = (collection, interfaceAst) => {
    const interfaceName = interfaceAst.name;
    if (collection[interfaceName] === undefined) {
        collection[interfaceName] = {
            properties: [],
            methods: [],
        };
    }

    const reduceMethod = addAstMemeberToCollection.bind(undefined, interfaceName);
    collection[interfaceName] = interfaceAst.members.reduce(reduceMethod, collection[interfaceName]);
    return collection;
};

/**
 * Adds a webidl2 generated AST for a namespace to a colleciton (mapping)
 * of namespace names to an object containing the properties and methods
 * that are defined on that namespace.
 *
 * This function is intended to be used when reducing a collection of namespace
 * ASTs (generated by the webidl2.parse method) to a single collection.
 *
 * @param {object} namespaceAst
 *   A object depicting the AST for an namespace, in the format
 *   returned from the webidl2.parse method.
 *
 * @return {object.<string, object.<string, array.string>>}
 *   An object that maps namespace names to the properties and methods
 *   defined on those namespaces, in the WebIDL text.
 */
const addNamespaceAstToCollection = (collection, namespaceAst) => {
    const namespaceName = namespaceAst.name;
    if (collection[namespaceName] === undefined) {
        collection[namespaceName] = {
            properties: [],
            methods: [],
        };
    }

    const elmsOfInterest = ["attribute", "operation"];
    const namespaceMembers = namespaceAst.members.filter(elm => {
        return elmsOfInterest.indexOf(elm.type) !== -1;
    });
    namespaceMembers.forEach(elm => {
        const memberBin = elm.type === "attribute"
            ? "properties"
            : "methods";

        const memberPath = `${namespaceName}.${elm.name}`;

        if (collection[namespaceName][memberBin].indexOf(memberPath) === -1) {
            collection[namespaceName][memberBin].push(memberPath);
        }
    });

    return collection;
};

/**
 * Adds the elements in a mixin to an interface, and returns a new interface AST
 * object, in the same format that webidl2.parse generates.
 *
 * @param {string} mixinName
 *   The name of the mixin being applied to the interface.
 * @param {object} mixinFeatures
 *   A `addInterfaceAstToCollection` generated object for a webidl2.parse
 *   generated "interface mixin" statement.
 * @param {string} interfaceName
 *  The name of the target interface.
 * @param {object} interfaceFeatures
 *   A `addInterfaceAstToCollection` generated object for a webidl2.parse
 *   generated "interface" statement.
 *
 * @return {object}
 *   A new object, in the format of a single value returned from
 *   `addInterfaceAstToCollection`, with the elements in the mixin
 *   applied to the feature.
 */
const applyMixinToInterface = (mixinName, mixinFeatures, interfaceName, interfaceFeatures) => {
    const newInterfaceFeatures = JSON.parse(JSON.stringify(interfaceFeatures));

    const rename = featureName => featureName.replace(mixinName, interfaceName);

    const renamedMixinMethods = mixinFeatures.methods.map(rename);
    const renamedMixinProperties = mixinFeatures.properties.map(rename);

    newInterfaceFeatures.methods = newInterfaceFeatures.methods.concat(renamedMixinMethods);
    newInterfaceFeatures.properties = newInterfaceFeatures.properties.concat(renamedMixinProperties);

    return newInterfaceFeatures;
};

/**
 * Creates a new AST tree, normalized, so that mixed in methods and properties
 * appear in the tree with the relevant Constructor.
 *
 * @param {object} ast
 *   An WebIDL AST generated by webidl2.parse.
 *
 * @return {object}
 *   A new object, that maps interface names to objects.  The child objects
 *   have "methods" and "properties" keys, that point to arrays of key paths.
 */
const astToInterfaces = ast => {
    // First, pull out all the interface and mixing elements from the AST.
    const astElmTemplate = {
        "namespaces": [],
        "interfaces": [],
        "mixins": [],
        // Mapping of targets (interface names) to mixin names.
        "includes": {},
    };

    const ofInterestAstTypes = ["interface", "interface mixin", "namespace"];
    const binMapping = {
        "interface": "interfaces",
        "interface mixin": "mixins",
        "includes": "includes",
        "namespace": "namespaces",
    };

    const astElms = ast.reduce((collection, elm) => {
        const elmBin = binMapping[elm.type];
        if (elmBin === undefined) {
            return collection;
        }

        if (elm.type === "includes") {
            const {target, includes} = elm;
            if (collection.includes[target] === undefined) {
                collection.includes[target] = [];
            }
            collection.includes[target].push(includes);
            return collection;
        }

        collection[elmBin].push(elm);
        return collection;
    }, astElmTemplate);

    const mixinFeatureMap = astElms.mixins.reduce(addInterfaceAstToCollection, {});
    const interfaceFeatureMap = astElms.interfaces.reduce(addInterfaceAstToCollection, {});
    const interfaceNameToFeaturesPairs = Object.entries(interfaceFeatureMap);

    const normalizedInterfaces = interfaceNameToFeaturesPairs
        .reduce((collection, item) => {
            const [interfaceName, interfaceFeatures] = item;
            const includesForInterface = astElms.includes[interfaceName];
            if (includesForInterface === undefined) {
                collection[interfaceName] = interfaceFeatures;
                return collection;
            }

            const mergedInterface = includesForInterface.reduce((collection, mixinName) => {
                const mixin = mixinFeatureMap[mixinName];
                return applyMixinToInterface(
                    mixinName,
                    mixin,
                    interfaceName,
                    collection
                );
            }, interfaceFeatures);

            collection[interfaceName] = mergedInterface;
            return collection;
        }, {});

    const allElementsInAst = astElms.namespaces.reduce(addNamespaceAstToCollection, normalizedInterfaces);
    return allElementsInAst;
};

/**
 * Parses an WebIDL text into an object, mapping the names of the interfaces
 * in the object to the methods and properties defined in the idl text.
 *
 * @param {string} idlText
 *   A string depicting a valid WebIDL document.
 *
 * @return {object.<string, array.string>}
 *   An object that maps interface names to the properties and methods
 *   defined on those interfaces, in the WebIDL text.
 *
 * @throws
 *   If the given IDL text is no valid WebIDL text.
 */
const idlTextToFeatures = idlText => {
    const standardAst = webidl2.parse(idlText);
    return astToInterfaces(standardAst);
};

module.exports.idlTextToFeatures = idlTextToFeatures;
